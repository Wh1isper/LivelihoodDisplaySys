WINDOWS98TTL:32LINU2.2X/2.4XTTL:64WINDOWSNT/2000/XPTTL:128UNIX/BSDTTL:255因为在数据包传送过程中,每经过一个路由,TTL值就会自动减1,所以上面的数值是个近似数值.可以通过tracert命令获得与远程主机间存在的路由个数,来确定精确的TTL值.光凭TTL值不足以确定的，还需要用tracert命令在cmd中输入tracertip，然后会列出一个IP表，数一下一共有几行。然后再加上53不过我估计你所说的53真实TTL是64也就是linux系统不过TTL是可以修改的，我这种方法也只能推测，不能100%肯定32=WIN9895（基本没人用）64=LINUX系列（不多）128=XP.2000.NT.ME（ME好象是）255=UNIX系列（蛮多）过一个路由减一是知道的吧。。。REGEDIT可修改，所以不可靠，TTL只是初步判断。从返回TTL值判断操作系统2009-03-2416:53TTL值全称是“生存时间（TimeToLive)”，简单的说它表示DNS记录在DNS服务器上缓存时间。TTL是IP协议包中的一个值，它告诉网络路由器包在网络中的时间是否太长而应被丢弃。有很多原因使包在一定时间内不能被传递到目的地。例如，不正确的路由表可能导致包的无限循环。一个解决方法就是在一段时间后丢弃这个包，然后给发送者一个报文，由发送者决定是否要重发。TTL的初值通常是系统缺省值，是包头中的8位的域。TTL的最初设想是确定一个时间范围，超过此时间就把包丢弃。由于每个路由器都至少要把TTL域减一，TTL通常表示包在被丢弃前最多能经过的路由器个数。当记数到0时，路由器决定丢弃该包，并发送一个ICMP报文给最初的发送者。Windows95/98中TTL的缺省值为32。有人建议当到达一个节点比较困难时，把此值设为128。ping和tracerouter都使用TTL值以尝试到达给定的主机或跟踪到那个主机的路由。traceroute把包的TTL值设得较小，使它在到达目的的路上被各个路由器连续的丢弃。发出包到受到返回的ICMP报文之间的时间用来计算从一个路由器到另一个路由器的时间。使用多路复用的IP协议，TTL值表示一个包被转发的范围。有以下转换：0，限制在同一主机1，限制在同一子网32，限制在同一节点64，限制在同一区域（region）128，限制在同一大陆（continent）255，由于不同的操作系统的默认TTL值不同，因此有文章说可以通过返回的TTL值判断目标系统的类型，这是正确的，但不是TTL的功能，只是对TTL理解的一个应用。TTL的值可以修改。有些特殊的、系统（如NIDS）会定义特殊的TTL值，以拒绝非法访问数据进入。我们在执行PING命令时可以用-i参数指定TTL值，大家可以将TTL设置为0，则该包将被立即丢弃。有时我们执行了一个PING命令，在繁华时却繁华了另一个地址，并带有一个英语的提示（大致意思是TTL无效），则表示该包在到达目标之前（也就是到返回IP位置时），包所带的TTL已经为0了或小于下一网段许可通过的TTL值了，该包已经被路由丢弃了。TTL是数据包生存周期,根据减少的数可以判断经过了多少中间设备在没有经过修改的情况下:UNIX及类UNIX操作系统ICMP回显应答的TTL字段值为255CompaqTru645.0ICMP回显应答的TTL字段值为64微软WindowsNT/2K操作系统ICMP回显应答的TTL字段值为128微软Windows95操作系统ICMP回显应答的TTL字段值为32LINUXKernel2.2.x&2.4.xICMP回显应答的TTL字段值为64FreeBSD4.1,4.0,3.4;SunSolaris2.5.1,2.6,2.7,2.8;OpenBSD2.6,2.7,NetBSDHPUX10.20ICMP回显应答的TTL字段值为255Windows95/98/98SEWindowsMEICMP回显应答的TTL字段值为32WindowsNT4WRKSWindowsNT4ServerWindows2000ICMP回显应答的TTL字段值为128这样，我们就可以通过这种方法来辨别操作系统TTLLINUX64WIN2K/NT128WINDOWS系列32UNIX系列255-------------------------------------------------------------------------------------------大家知道，通过Ping和Tracert程序就能判断目标主机类型，Ping最主要的用处就是检测目标主机是否能连通。Tracert利用ICMP数据包和IP数据包头部中的TTL值，防止数据包不断在IP互联网上永不终止地循环。许多入侵者首先会Ping一下你的机子，如看到TTL值为128就认为你的系统为WindowsNT/2000;如果TTL值为32则认为目标主机操作系统为Windows95/98;如果TTL值为255/64就认为是UNIX/Linux操作系统。既然入侵者相信TTL值所反映出来的结果，那么我们只要修改TTL值，入侵者就无法入侵电脑了。操作步骤:1.打开“记事本”程序，编写批处理命令:@echoREGEDIT4>>ChangeTTL.reg@echo.>>ChangeTTL.reg@echo[HKEY_LOCAL_MACHlNE\System\CurrentControlSet\Services\Tcpip\Parameters]>>ChangeTTL.reg@echo"DefaultTTL"=dword:000000">>ChangeTTL.reg@REGEDIT/S/CChangeTTL.reg2.把编好的程序另存为以.bat为扩展名的批处理文件，点击这个文件，你的操作系统的缺省TTL值就会被修改为ff，即10进制的255，也就是说把你的操作系统人为地改为UNIX系统了。同时，在该文件所在的文件夹下会生成一个名为ChangeTTL.reg的注册表文件。如果你想运行完这个批处理文件而不产生ChangeTTL.reg文件，可以在此批处理文件的最后一行加上deltree/YChangeTTL.reg，就可以无须确认自动删除ChangeTTL.reg文件。说明:在上面的命令中，echo是DOS下的回显命令，如果想看到程序执行过程，请将“@”去掉。“>>”产生的内容将追加到它后面的文件即ChangeTTL.reg中。而“DefaultTTL"=dword?000000ff”则是用来设置系统缺省TTL值的，如果你想将自己的操作系统的TTL值改为其他操作系统的ICMP回显应答值，请改变“"DefaultTTL"”的键值，要注意将对应操作系统的TTL值改为十六进制才可以。这样，当入侵者Ping你的机器时，他得到的就是一个假的TTL值，这个假的TTL值就会误导对方，使入侵者的判断出现失误，因为针对不同的操作系统的入侵方法并不一样，所以用这个方法欺骗对方，可以让他摸不着头脑!利用这个方法欺骗入侵者是不是很妙啊?