单链表的基本操作：#include<iostream>usingnamespacestd;classNode{public:intmydata;Node*next;Node(){next=NULL;}Node(intdata,Node*next1){mydata=data;next=next1;}};classSingleLinkedList{public:Node*head,*s,*p;SingleLinkedList();SingleLinkedList(inta[],intn);~SingleLinkedList();intLength();intGet(inti);intLocate(intx);voidInsert(inti,intx);intDelete(inti);voidPrintList();};SingleLinkedList::SingleLinkedList(){head=newNode;head->next=NULL;}SingleLinkedList::SingleLinkedList(inta[],intn){head=newNode;p=head;for(inti=0;i<n;i++){s=newNode;s->mydata=a[i];p->next=s;p=s;}p->next=NULL;}intSingleLinkedList::Length(){intcount;s=head->next;count=0;while(s!=NULL){s=s->next;count++;}returncount;}intSingleLinkedList::Get(inti){intcount;s=head->next;count=1;while(s!=NULL&&count<i){s=s->next;count++;}if(s==NULL)throw"位置";elsereturns->mydata;}intSingleLinkedList::Locate(intx){intcount;s=head->next;count=1;while(s!=NULL){if(s->mydata==x)returncount;s=s->next;count++;}return0;}voidSingleLinkedList::Insert(inti,intx){s=head;intcount=0;while(s!=NULL&&count<i-1){s=s->next;count++;}if(s==NULL)throw"位置";else{p=newNode;p->mydata=x;p->next=s->next;s->next=p;}}intSingleLinkedList::Delete(inti){intx;s=head;intcount=0;while(s!=NULL&&count<i-1){s=s->next;count++;}if(s==NULL||s->next==NULL)throw"位置";else{p=s->next;x=p->mydata;s->next=p->next;deletep;returnx;}}voidSingleLinkedList::DeleteBetween(intmink,intmaxk){p=head;while(p->next!=NULL&&p->next->mydata<=mink){p=p->next;}if(p->next!=NULL)//新增删除mink和maxk之间的结点{s=p->next;while(s->mydata<maxk){u=s->next;p->next=s->next;deletes;s=u;}}}voidSingleLinkedList::PrintList(){s=head->next;while(s!=NULL){cout<<s->mydata<<endl;s=s->next;}}SingleLinkedList::~SingleLinkedList(){while(head!=NULL){s=head;head=head->next;deletes;}}voidmain(){inta[4]={1,2,2,4};SingleLinkedListlist(a,4);//list.Delete(2);list.Insert(2,5);list.PrintList();}单循环链表基本操作：/*1：输出单向循环链表的所有结点的值2：查找第i个结点或值为某一个值的结点3：在指定的地方插入一个结点4：删除指定的结点5:退出系统*/#include"stdio.h"#include"stdlib.h"#include"string.h"#include"malloc.h"#include"iostream.h"#defineDATATYPEcharstructLINKLIST{DATATYPEdata;structLINKLIST*next;};voidprint(structLINKLIST*head)//输出链表元素{structLINKLIST*p;//定义一个指针p=head->next;cout<<"输出元素值：";while(p!=head){cout<<p->data<<"";p=p->next;}}voidget(inti,structLINKLIST*head)//按序号查找{structLINKLIST*p;intj;j=0;p=head;while((j<i)&&(p->next!=head)){p=p->next;j++;}if(j==i)cout<<"您要找的第"<<i<<"个元素是："<<p->data;elsecout<<"没有找到您要找的元素！";}structLINKLIST*locat(DATATYPEx,structLINKLIST*head)//按值查找元素{structLINKLIST*p;p=head->next;while(p!=head){if(p->data==x){returnp;}else{p=p->next;}}if(p==head){returnNULL;}}voidinsertafter(DATATYPEinsertdata,structLINKLIST*p)//在已知结点之后插入一个结点{LINKLIST*t;if(p){t=(structLINKLIST*)malloc(sizeof(structLINKLIST));t->data=insertdata;t->next=p->next;p->next=t;}}intdeletafter(structLINKLIST*head,structLINKLIST*p)//删除后继结点{structLINKLIST*t;intr=1;if(p->next!=head){t=p->next;p->next=t->next;free(t);}elser=0;returnr;}intdeletself(structLINKLIST*head,structLINKLIST*p)//删除结点本身{LINKLIST*q;q=head;if(!p)return0;elsewhile(q->next!=p&&q->next!=head)q=q->next;q->next=p->next;free(p);return1;}voidmain(){inti;LINKLIST*p;LINKLIST*head,*t,*last;//p=head;t=(LINKLIST*)malloc(sizeof(LINKLIST));//单链表的建立(尾插入法)charch,insertdata;head=t;last=t;t->next=head;printf("单链表元素为单个字符，连续输入(不要空格)，以“0”为结束标志:\n");while((ch=getchar())!='0'){t=(LINKLIST*)malloc(sizeof(LINKLIST));t->data=ch;t->next=head;last->next=t;last=t;}cout<<endl<<"/*********************************************/";cout<<endl<<"/*************单向循环链表的操作**************/";cout<<endl<<"/*********************************************/";cout<<endl<<"/******************欢迎使用！*****************/";cout<<endl<<"/*********************************************/";cout<<endl<<"/*************制作者：xxyshow115、just、ㄣ黑銫禮ゞ菔******/";cout<<endl<<"/*********************************************/";cout<<endl<<endl<<"1………………………输出链表元素";cout<<endl<<"2………………………按序号查找元素";cout<<endl<<"3………………………按值查找元素";cout<<endl<<"4………………………在指定结点后插入元素";cout<<endl<<"5………………………删除后继结点";cout<<endl<<"6………………………删除结点本身";cout<<endl<<"7………………………退出系统";do{cout<<endl<<"请选择您要执行的操作：";cin>>i;switch(i){case1:print(head);break;case2:intj;cout<<"请输入你要查找的序号：";cin>>j;get(j,head);break;case3:cout<<"请输入你要查找的字符：";cin>>ch;p=locat(ch,head);if(p)cout<<"已经找到你要的元素:"<<p->data;elsecout<<endl<<"无此结点!";break;case4:cout<<"在哪个结点后插入:";cin>>ch;p=locat(ch,head);if(!p)cout<<endl<<"您输入的值不存在！";else{cout<<"插入结点值:";cin>>insertdata;insertafter(insertdata,p);cout<<endl<<"操作后的链表为：";print(head);}break;case5:cout<<"删除哪个结点的后继:";cin>>ch;p=locat(ch,head);if(!p)cout<<endl<<"您输入的值不存在！";else{if(deletafter(head,p))cout<<"删除成功！";cout<<"操作后的链表为：";print(head);}break;case6:cout<<"删除哪个结点:";cin>>ch;p=locat(ch,head);if(!p)cout<<endl<<"您输入的值不存在！";else{if(deletself(head,p))cout<<"删除成功！";cout<<"操作后的链表为：";print(head);}break;case7:exit(0);}}while(i!=7);}单循环链表拆分算法：#include<iostream>usingnamespacestd;classNode{public:intmydata;Node*next;Node(){next=NULL;}Node(intdata,Node*next1){mydata=data;next=next1;}};classSingleLinkedList{public:Node*head,*s,*p;SingleLinkedList(inta[],intn);//~SingleLinkedList();voidPrintList1();voidPrintList2();};SingleLinkedList::SingleLinkedList(inta[],intn){head=newNode;p=head;for(inti=0;i<n;i++){s=newNode;s->mydata=a[i];p->next=s;p=p->next;}s->next=head;}voidSingleLinkedList::PrintList1(){s=head;while(s->next!=head){cout<<s->next->mydata<<endl;s=s->next->next;}}voidSingleLinkedList::PrintList2(){intb[3];s=head->next;while(s!=head){for(intj=2;j>=0;j--){b[j]=s->next->mydata;s=s->next->next;}for(j=0;j<3;j++){cout<<b[j]<<endl;}}}/*SingleLinkedList::~SingleLinkedList(){while(s->next!=head){s=head;head=head->next;deletes;}}*/voidmain(){inta[6]={1,2,3,4,5,6};SingleLinkedListlist1(a,6);SingleLinkedListlist2(a,6);cout<<"list1遍历结果："<<endl;list1.PrintList1();cout<<"list2遍历结果："<<endl;list1.PrintList2();}//假设以不带头结点的循环链表表示队列，并只设一个尾结点指向队尾结点。#include<iostream>usingnamespacestd;classNode{public:intdata;Node*next;};classCirQuenue{private:Node*rear,*s,*p;public:CirQuenue(){rear=NULL;}~CirQuenue(){}voidenqueue(intx);voiddequeue();intGetqueue();//intempty(){return(front==rear)?1:0;}};voidCirQuenue::enqueue(intx){s=newNode;s->data=x;if(rear==NULL){rear=s;rear->next=s;}else{s->next=rear->next;rear->next=s;rear=s;}}voidCirQuenue::dequeue(){if(rear==NULL)throw"下溢";else{s=rear->next;if(s==rear)rear=NULL;elserear->next=s->next;deletes;}}intCirQuenue::Getqueue(){if(rear==NULL)cout<<"下溢";returnrear->next->data;}voidmain(){CirQuenuelist;list.enqueue(2);list.enqueue(3);list.enqueue(4);list.enqueue(5);list.dequeue();cout<<list.Getqueue();}